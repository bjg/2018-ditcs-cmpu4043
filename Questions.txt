C15423602-wks-3
________________

1. Explain what is meant by the stream abstraction. What is the relationship between streams and the observer pattern? What are streams useful for modelling and when might you use them in Rich Web development?

Stream abstraction are used to model asynchronous data sources. It's a powerful technique when processing data if the potential size or arrival time period is unknown or uncertain. The processing of streams must be done in time-separated chunks in sequence or concurrently, hence in streams.
	While streams work by pushing data as it becomes available, the observer pattern is the object literal to capture values observed and returned before reaching a final block. Observers are a collection of callbacks that knows how to listen to values delivered by the Observable. 
	Streams are useful in Rich Web development as mentioned before, streams provides asynchronous solutions to a problem. Using streams allows the application architecture to reduce a stream processing problem to merge into one or more data streams. This applies to  mouse clicks, keyboard inputs and network responses.

__________________

2. Assume that you are building an interface to an API in your Rich Web App. Describe in detail how you could use the RxJS library to handle asynchronous network responses to API requests. In your opinion, what are the benefits to using a streams library for networking over, say, promises? And what do you think are the downsides?


We use RxJS to implement event stream abstraction to make it easier to compose asynchronous or callback-based code. It has better performance, better modularity and better debuggable call stacks. What makes RxJS powerful is its ability to produce values using pure functions, meaning your code is less prone to errors. To get started with RxJS, a web pack bundle is to be installed, through this the server is called and the application will be run through that. The bundle includes a web pack-config which serves as a configuration entry point for paths, JSON packages.

Promises are values that capture a future value which can be processed independently from the rest of the API calls. They can also be composed or passed as an argument to functions, which can be resolved or rejected when future values arrive. Promises can also be chained to provide the same functionality as nested callbacks, which might be a downfall as if the promise is rejected, then the whole callback is rejected.